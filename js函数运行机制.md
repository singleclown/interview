### 函数上下文
当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。
创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段。
	1	this 值的决定，即我们所熟知的 This 绑定。
	2	创建词法环境组件。（作用域）
	3	创建变量环境组件。
#### 上下文:每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。
 
* 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
* 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部

对于每个执行上下文，都有三个重要属性：
* 变量对象(Variable object，VO)包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
* 作用域链(Scope chain)JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）
* this
* JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。
* JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的

词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。
简单来说词法环境是一种持有标识符—变量映射的结构。（这里的标识符指的是变量/函数的名字，而变量是对实际对象[包含函数类型对象]或原始数据的引用）。
	•	全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this的值指向全局对象。
	•	在函数环境中，函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。
现在，在词法环境的内部有两个组件：(1) 环境记录器和 (2) 一个外部环境的引用。
1. 环境记录器是存储变量和函数声明的实际位置。
2. 外部环境的引用意味着它可以访问其父级词法环境（作用域）。
词法环境包含环境记录器（存储变量和函数声明的实际位置。）和一个外部环境的引用(作用域链)
词法环境2种类型全局和函数
环境记录器2种类型
	•	在全局环境中，环境记录器是对象环境记录器。
	•	在函数环境中，环境记录器是声明式环境记录器。
注意 — 对于函数环境，声明式环境记录器还包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。
在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。
因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。
变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
全局上下文中的变量对象就是全局对象呐！
在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。
活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。
活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。
变量对象会包括：
1. 函数的所有形参 (如果是函数上下文)
    * 由名称和对应值组成的一个变量对象的属性被创建
    * 没有实参，属性值设为 undefined
2. 函数声明
    * 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
    * 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
    * 由名称和对应值（undefined）组成一个变量对象的属性被创建；
    * 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性



* 变量提升：JavaScript 仅提升声明，而不提升初始化。
变量提升（Hoisting）被认为是， Javascript中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。
变量提升只将声明部分提升，赋值部分不改变位置；函数变量优于变量提升；var 声明可以同名可以被覆盖。

var a = 6;function b (){console.log(a);var a = 4; function a (){alert(4)};console.log(a)}b();
var a = 6;function b (){console.log(a);var a = 4; var a = function  (){alert(4)};}b();
var a = 6;function b (){console.log(a);var a = 4; let a = function  (){alert(4)};}b();
console.log(b);
b() // call b second

function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world’;
for（父级作用域）{子级作用域
}
注意变量提升
匿名函数表达式提升变量名，而不是函数赋值
很❤命名函数表达式提升的是变量名，而不是函数名或者函数体，函数声明提升其名称和函数体

// 函数表达式
baz(); // TypeError: baz is not a function
 
var baz = function(){
    console.log(200);
}
 
//相当于
 
var baz;
 
baz();
 
baz = function() {
    console.log(200);
};

函数声明提升会在编译阶段把声明和函数体整体都提前到执行环境顶部，所以我们可以在函数声明之前调用这个函数

函数表达式，其实就是变量声明的一种，声明操作会被提升到执行环境顶部，并赋值undefined。赋值操作被留在原地等到执行。