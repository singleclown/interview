### Ajax
提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是 readyState 和 status ，readyState 通过5个状态码来描述一个请求的5个阶段-创建的xhr对象，它对应有5状态(readyState属性)：
0 - 请求未发送，初始化阶段  Uninitialized（尚未调用open方法）
1 - 请求发送中，服务器还未收到请求 Loading （已调用open，尚未调用send）
2 - 请求发送成功，服务器已收到请求 Loaded (已经调用send，尚未接收到响应)
3 - 服务器处理完成，开始响应请求，传输数据  Interactive （开始接收数据）
4 - 客户端收到请求，并完成了数据下载，生成了响应对象  Complete (数据接收完毕，响应内容解析完成)
注意点：request.open() 并没有发送请求，只是设置一些参数，在 send() 时才会发送（注意不要漏写这条语句），发送后就会进入 readyState 监听状态，当 readyState 的值有改变就会执行 onreadystatechange 回调函数，当异请求的步数据接收完成（即      readyState 变为 4）后就会执行      onload 回调函数（注意仅在 XHR2 中有效



超时问题：代表着一个请求在被自动终止前所消耗的毫秒数(客户端超时，代理超时，服务端超时)
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
408 （请求超时） 服务器等候请求时发生超时。
可以使用一个超时设置,来避免你的代码为了等候读取请求的返回数据长时间执行.超时毫秒数.超时时间的计算，是从调用xhr.send()开始，至xhr.loadend触发为止的这段时间。即时xhr.timeout的设置是在xhr.send()之后，timeout的计时起点仍为调用xhr.send()的时刻。
注意点：Ajax对象还可以设置一个timeout 值，代表超时时间，切记：timeout 只会影响readyState，而不会影响status，因为超时只会中断数据传输，但不会影响服务器的处理结果。 如果 timeout 设置的不合理，就会导致响应码status 是200，但 response里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了

报文结构
1. 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。
2. 一个可选的HTTP头集合指明请求或描述消息正文。
3. 一个空行指示所有关于请求的元数据已经发送完毕。
4. 一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。
https协议
安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。
通信流程
1、客户端发起HTTPS请求
这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。
2、服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。
这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3、传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4、客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5、传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6、服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7、传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
8、客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。
HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。
SSL建立握手连接目的：
1.身份的验证，client与server确认对方是它相连接的，而不是第三方冒充的，通过证书实现
2.client与server交换session key，用于连接后数据的传输加密和hash校验
CORS 模型，即 跨域资源共享， 它不是一个新的API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。 
优势：
1.线头阻塞：HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。
队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:
* 将同一页面的资源分散到不同域名下，提升连接上限。 Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。
2.http2：帧结构
它把TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。
HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
3.Header 压缩
HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。
具体来说:
* 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；
* 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
* 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值
HTTP /2 不再依赖 TCP 链接去实现多流并行了
“h2"表示加密的HTTP/2，“h2c”表示明文的HTTP/2。
那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：
1. 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
2. 和服务器建立多个 TCP 连接。
HTTP /2(HTTP流水线) HTTP Pipelining默认关闭的可以实现多个并行
如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。
如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。


Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。
在以下两种情况下，Referer 不会被发送： 

1.来源页面采用的协议为表示本地文件的 "file" 或者 "data" URI； 

2.当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）。

3.直接输入网址或通过浏览器书签访问 

4.使用 JavaScript 的 Location.href 或者是 Location.replace()

5.使用html5中noreferrer 

<a href="/test/index.php?noreferer" rel="noreferrer" target="_blank">noreferrer</a> 
<a href="/test/index.php?noreferer" rel="noreferrer" target="_blank">noreferrer</a>
6.使用 Referer Meta 标签控制 referer 使用场景，具体参考如下文章：https://www.jb51.net/article/137982.htm

7.使用iframe的hack写法去除referer


host的值为客户端请求的服务器的域名（或者ip）和端口
host用的最多的场景是：单台服务器设置多个虚拟主机时。
Origin 请求首部字段 Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。该首部用于 CORS 请求或者 POST 请求。除了不包含路径信息，该字段与 Referer 首部字段相似

referer与origin功能相似，但是还是有几点不同，仔细看上面的介绍，总结如下几点：

1、只有跨域请求，或者同域时发送post请求，才会携带origin请求头，而referer不论何种情况下，只要浏览器能获取到请求源都会携带，除了上面提到的几种情况。

2、如果浏览器不能获取请求源，那么origin满足上面情况也会携带，不过其值为null，如图：


这点与referer不同，浏览器如果不能获取请求源，那么请求头中不会携带referer。

3、origin的值只包括协议、域名和端口，而erferer不但包括协议、域名、端口还包括路径，参数，注意不包括hash值。
为了防止CSRF的攻击，我们建议修改浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。
隐私方面：这种Origin字段的方式比Referer更人性化，因为它尊重了用户的隐私。

1、Origin字段里只包含是谁发起的请求，并没有其他信息 (通常情况下是方案，主机和活动文档URL的端口)。跟Referer不一样的是，Origin字段并没有包含涉及到用户隐私的URL路径和请求内容，这个尤其重要。

2、Origin字段只存在于POST请求，而Referer则存在于所有类型的请求。
跨域解决方案
1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域



转发是服务器行为，重定向是客户端行为
Forward是在服务器端的跳转，就是客户端一个请求发给服务器，服务器直接将请求相关的参数的信息原封不动的传递到该服务器的其他jsp或servlet去处理，而sendredirect是在客户端的跳转，服务器会返回给客户端一个响应报头和新的URL地址，原来的参数什么的信息如果服务器端没有特别处理就不存在了，浏览器会访问新的URL所指向的servlet或jsp，这可能不是原先服务器上的webservce了。
重定向过程：后端返回特定的路径和状态码，前端二次请求
    客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。

跨域解决方案
1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

Cookie :①不能不同的浏览器②可以不同的tab页③必须同源④必须同一路径或者子路径下
Localstorage:①不能不同的浏览器②可以不同的tab页③必须同源④可以在不同的浏览器窗口中
Sesstionstorage:①不能不同的浏览器②不可以不同的tab页③必须同源
cookie: path：只有与创建cookie的页面处于同一个目录或在创建cookie页面的子目录下的网页才能访问
Domain：cookie所在的域默认为请求的地址。例如https://www.haorooms.com/post/long_lianjie_websocket域名就是www.haorooms.com。跨域访问就是域A love.haorooms.com，域B resource.haorooms.com域名设置为.haorooms.com
Cookie的跨域访问.可以共享，根据同源策略cookie是区分端口的，但是对浏览器来说，cookie是区分域，不区分端口的，在一个ip地址下多个端口的cookie是共享的
通过jsonp和nginx和superagent
Localstorage跨域使用postmessage和iframe
cookie字段expires、domain、path、secure、HttpOnly
￼