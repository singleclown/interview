基础知识js系列八
1.2 八大常见的数据结构
1. 数组： Array
2. 堆栈： Stack
3. 队列： Queue
4. 链表： Linked Lists
5. 树： Trees
6. 图： Graphs
7. 字典树： Trie
8. 散列表（哈希表）： Hash Tables
在较高的层次上，基本上有三种类型的数据结构:
* 堆栈和队列是类似于数组的结构，仅在项目的插入和删除方式上有所不同。
* 链表，树，和图 结构的节点是引用到其他节点。
* 散列表依赖于散列函数来保存和定位数据。
在复杂性方面：
* 堆栈和队列是最简单的，并且可以从中构建链表。
* 树和图 是最复杂的，因为它们扩展了链表的概念。
* 散列表和字典树 需要利用这些数据结构来可靠地执行。
就效率而已：
* 链表是记录和存储数据的最佳选择
* 而哈希表和字典树 在搜索和检索数据方面效果最佳。
单向链表
随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关，例如数组。
非随机存取就是顺序存取了，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表
* 什么是单链表？
　　由于顺序表在插入和删除是需要做大量的元素移动工作，而且需要连续的物理空间，因此其缺点是十分明显的，为了解决这一问题，不需要预先分配连续的内存地址空间、插入删除元素不需要做大量移动工作的链表出现了。但解决问题的同时也拥有自己的缺点，即不能随机存取。
　　在链表中，每个数据元素是一个节点，每个节点包含两部分，存续元素信息的数据域和存储后继节点存储位置的指针域。
　　其中，头指针指示链表中第一个节点的存储位置，头结点为在第一个元素前附设的一个节点，最后一个节点因为没有后继节点，因此指针域为空。
　　
￼
　　正是因为链表的这种结构，导致链表不可以随机访问数据元素，只能从第一个元素一个一个的访问，因此，对于单链表来说，插入删除元素是高效的，而访问元素是低效的。
但是在js中由于我们可以动态的扩充数组，加之有丰富的原生api。我们通常并不需要实现链表结构。
头指针就是链表的名字。头指针仅仅是个指针而已。

头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。
有了头结点后，对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。
首元结点也就是第一个元素的结点，它是头结点后边的第一个结点。
头结点不是链表所必需的。
是的，对于头指针，我们也可以有相应的理解了。
在线性表的链式存储结构中，头指针是指链表指向第一个结点的指针，若链表有头结点，则头指针就是指向链表头结点的指针。
头指针具有标识作用，故常用头指针冠以链表的名字。
无论链表是否为空，头指针均不为空。头指针是链表的必要元素
单向链表：
结点

// 链表节点
class Node {
  constructor(data) {
    this.data = data;//节点数据-值域
    this.next = null;//下一个节点的指针-指针域
  }
}
//链表
class NodeList {
  constructor() {
    this.head = null;
    this.length = 0;
  }
  size = () => {
    return this.length;
  }
  isEmpyt = () => {
    return !this.length;
  }
  //向链表的末尾添加一个元素
  append = (data) => {
    const newNode = new Node(data);
    let currentNode = null;
    if (!this.head) {
      this.head = new Node(data);
    }
    currentNode = this.head;
    while (currentNode.next) {
      currentNode = currentNode.next;
    }
    currentNode.next = newNode;
    this.length++;
  }
  //列表的特定位置插入一个新的项，返回最终插入的位置
  insert = (position, data) => {
    position = +position;
    if (isNaN(position) || position > this.length) {
      position = this.length;
    } else {
      position = 0;
    }
    var index = 0;
    var previousNode = null;
    var current = this.head;
    const newNode = new Node(data);
    while (index++ < position) {
      previousNode = current;
      current = previousNode.next;
    }
    previousNode.next = newNode;
    newNode.next = current;
    this.length++;
  }
  //链表中特定位置移除元素
  removeAt = (position) => {
    position = +position;
    if (isNaN(position) || position > this.length) {
      position = this.length;
    } else {
      position = 0;
    }
    var index = 0;
    var previousNode = null;
    var current = this.head;
    while (index++ < position) {
      previousNode = current;
      current = previousNode.next;
    }
    previousNode.next = current.next;
    this.length--;
  }
  //返回元素在列表中的索引，如果列表中没有该元素则返回-1
  findNode = (data) => {
    let index = -1;
    var current = this.head;
    while (current) {
      index++;
      if (data instanceof Object) {
        if (JSON.stringify(current.data) === JSON.stringify(data)) {
          break;
        }
      } else {
        if (current.data === data) {
          break;
        }
      }
      current = current.next;
    }
    return index;
  }
  print=()=>{
    const list=[];
    let current=this.head;
    while(current){
      current=current.next;
      list.push(current.data);
    }
    return list.join("=>")
  }
}
<img src="./imgs/双向链表.png" width="50%" height="50%">
// 链表节点
class Node {
    constructor(data) {
      this.data = data;//节点数据-值域
      this.next = null;//下一个节点的指针-指针域
      this.previousNode = null;
    }
  }
  //链表
  class doubleNodeList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    isEmpty = () => {
      return this.length === 0;
    }
  
    //向链表的头、末尾、中间添加一个元素添加一个元素
    append = (position, data) => {
        debugger;
      if (!this.head) {
        this.head = new Node(data);
        this.tail = new Node(data);
      } else {
        position = +position;
        if (isNaN(position) || position >= this.length) {
          position = this.length;
        } else {
          position = 0;
        }
        var index = 0;
        var previousNode = null;
        var current = this.head;
        const newNode = new Node(data);
        if (!position) {
          //头部插入节点
          newNode.next = current;
          current.previousNode = newNode;
          this.head = newNode;
        } else if (position === this.length) {
          //尾部插入节点
          current = this.tail;
          newNode.previousNode = current;
          current.next = newNode;
          this.tail = newNode;
          if(this.length===1){
            this.head = current;
          }
        } else {
          //中间序号插入节点
          while (index++ < position) {
            previousNode = current;
            current = previousNode.next;
          }
          previousNode.next = newNode;
          newNode.next = current;
          newNode.previousNode=previousNode;
          current.previousNode=newNode;
        }
      }
      this.length++;
    }
      //链表中特定位置移除元素
      removeAt = (position) => {
        position = +position;
        if (isNaN(position) || position > this.length) {
          position = this.length;
        } else {
          position = 0;
        }
        var index = 0;
        var previousNode = null;
        var current = this.head;
        if (!position) {
          //头部删除节点
          current.next.previousNode = null;
          this.head = current.next;
        } else if (position === this.length) {
          //尾部删除节点
          current = this.tail;
          current.previousNode.next = null;
          this.tail = current.previousNode;
        } else {
          //中间序号删除节点
          while (index++ < position) {
            previousNode = current;
            current = previousNode.next;
          }
          previousNode.next = current.next;
          previousNode=current.next.previousNode;
        } 
        this.length--;
      }
      print=()=>{
        const list=[];
        const preList=[];
        let current=this.head;
        let preNode=this.tail;
        while(current){
            list.push(current.data);
          current=current.next;
          
        }
        while(preNode){
            preList.push(preNode.data);
          preNode=preNode.previousNode;
          
        }
        return [list.join("=>"),preList.join("<=")]
      }
  }